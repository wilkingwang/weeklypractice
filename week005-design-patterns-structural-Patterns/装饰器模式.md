### 一、意图
&ensp;&ensp;&ensp;&ensp;**装饰器模式**是一种结构型设计模式，允许你将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。

### 二、问题
&ensp;&ensp;&ensp;&ensp;假设你正在开发一个提供通知功能的库， 其他程序可使用它向用户发送关于重要事件的通知。

&ensp;&ensp;&ensp;&ensp;库的最初版本基于 通知器Notifier类， 其中只有很少的几个成员变量， 一个构造函数和一个 send发送方法。 该方法可以接收来自客户端的消息参数， 并将该消息发送给一系列的邮箱， 邮箱列表则是通过构造函数传递给通知器的。 作为客户端的第三方程序仅会创建和配置通知器对象一次， 然后在有重要事件发生时对其进行调用。
<div align=center><img src="decorator_pattern_question.png"></div>

&ensp;&ensp;&ensp;&ensp;此后某个时刻， 你会发现库的用户希望使用除邮件通知之外的功能。 许多用户会希望接收关于紧急事件的手机短信， 还有些用户希望在微信上接收消息， 而公司用户则希望在 QQ 上接收消息。
<div align=center><img src="decorator_pattern_question2.png"></div>

&ensp;&ensp;&ensp;&ensp;这有什么难的呢？ 首先扩展 通知器类， 然后在新的子类中加入额外的通知方法。 现在客户端要对所需通知形式的对应类进行初始化， 然后使用该类发送后续所有的通知消息。

&ensp;&ensp;&ensp;&ensp;但是很快有人会问： ​ “为什么不同时使用多种通知形式呢？ 如果房子着火了， 你大概会想在所有渠道中都收到相同的消息吧。”

&ensp;&ensp;&ensp;&ensp;你可以尝试创建一个特殊子类来将多种通知方法组合在一起以解决该问题。 但这种方式会使得代码量迅速膨胀， 不仅仅是程序库代码， 客户端代码也会如此。
<div align=center><img src="decorator_pattern_question3.png"></div>
&ensp;&ensp;&ensp;&ensp;你必须找到其他方法来规划通知类的结构， 否则它们的数量会在不经意之间打破吉尼斯纪录。

### 三、解决方案
&ensp;&ensp;&ensp;&ensp;当你需要更改一个对象的行为时，第一个跳入脑海的想法就是扩展它所属的类。但是，你不能忽视继承可能引发的几个严重的问题。

- 继承时静态的。你无法在运行时更改已有对象的行为，只能使用由不同子类创建的对象来替代当前的整个对象。
- 子类只能有一个父类。大部分编程语言不允许一个类同时继承多个类的行为。

&ensp;&ensp;&ensp;&ensp;其中一种方法是用聚合或组合，而不是继承。两者的工作方式几乎一模一样：一个对象包含指向另一个对象的引用，并将部分工作委派给引用对象；继承中的对象则继承父类的行为，它们自己能够完成这些工作。

&ensp;&ensp;&ensp;&ensp;封装器是装饰器模式的别称，这个称谓明确地表达了该模式的主要思想。 ​ “封装器” 是一个能与其他 “目标” 对象连接的对象。 封装器包含与目标对象相同的一系列方法， 它会将所有接收到的请求委派给目标对象。 但是， 封装器可以在将请求委派给目标前后对其进行处理， 所以可能会改变最终结果。

&ensp;&ensp;&ensp;&ensp;那么什么时候一个简单的封装器可以被称为是真正的装饰呢？ 正如之前提到的， 封装器实现了与其封装对象相同的接口。 因此从客户端的角度来看， 这些对象是完全一样的。 封装器中的引用成员变量可以是遵循相同接口的任意对象。 这使得你可以将一个对象放入多个封装器中， 并在对象中添加所有这些封装器的组合行为。

&ensp;&ensp;&ensp;&ensp;比如在消息通知示例中， 我们可以将简单邮件通知行为放在基类 通知器中， 但将所有其他通知方法放入装饰中。
<div align=center><img src="decorator_pattern_solution.png"></div>

&ensp;&ensp;&ensp;&ensp;客户端代码必须将基础通知器放入一系列自己所需的装饰中。 因此最后的对象将形成一个栈结构。
<div align=center><img src="decorator_pattern_solution_1.png"></div>
&ensp;&ensp;&ensp;&ensp;实际与客户端进行交互的对象将是最后一个进入栈中的装饰对象。 由于所有的装饰都实现了与通知基类相同的接口， 客户端的其他代码并不在意自己到底是与 “纯粹” 的通知器对象， 还是与装饰后的通知器对象进行交互。

&ensp;&ensp;&ensp;&ensp;我们可以使用相同方法来完成其他行为 （例如设置消息格式或者创建接收人列表）。 只要所有装饰都遵循相同的接口， 客户端就可以使用任意自定义的装饰来装饰对象。

### 四、装饰器模式结构

<div align=center><img src="decorator_pattern_structure.png"></div>

### 五、装饰器适合的应用场景
- 如果你希望在无需修改代码的情况下即可使用对象，且希望在运行时为对象新增额外的行为，可以使用装饰器模式
&ensp;&ensp;&ensp;&ensp;装饰能将业务逻辑组织为层次结构，你可为各层创建一个装饰，在运行时将各种不同逻辑组合为对象。由于这些对象都遵循通用接口，客户端代码能以相同的方式使用这些对象。
- 如果用继承来扩展对象行为的方案难以实现或根本不可行，可以使用装饰器模式
&ensp;&ensp;&ensp;&ensp;许多编程语言使用**final**最终关键字来限制对某个类的进一步扩展。 复用最终类已有行为的唯一方法是使用装饰模式： 用封装器对其进行封装。

### 六、实现方式
- 确保业务可用一个基本组件及多个额外可选层次表示
- 找出基本组件和可选层次的通用方法。创建一个组件接口并在其中生命这些方法
- 创建一个具体组件类，并定义其基础行为
- 创建装饰基类，使用一个成员变量存储指向被封装对象的引用。 该成员变量必须被声明为组件接口类型， 从而能在运行时连接具体组件和装饰。 装饰基类必须将所有工作委派给被封装的对象。
- 确保所有类实现组件接口。
- 将装饰基类扩展为具体装饰。 具体装饰必须在调用父类方法 （总是委派给被封装对象） 之前或之后执行自身的行为。
- 客户端代码负责创建装饰并将其组合成客户端所需的形式。

