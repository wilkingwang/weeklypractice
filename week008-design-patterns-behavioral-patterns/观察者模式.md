### 一、意图
&ensp;&ensp;&ensp;&ensp;**观察者模式**是一种行为设计模式，允许你定义一种订阅机制，可以在对象事件发生时通知多个"观察"该对象的其他对象。

### 二、问题
&ensp;&ensp;&ensp;&ensp;假如你有两类对象：`顾客`和`商店`，顾客对某个固定品牌的产品非常感兴趣，而该产品很快将会在商店出售。
&ensp;&ensp;&ensp;&ensp;顾客可以每天来商店看看产品是否到货。但如果商品未到货时，绝大多数来到商店的顾客都会空手而归。
&ensp;&ensp;&ensp;&ensp;另一方面，每次新产品到货时，商店可以向所有顾客发送邮件，这样，部分顾客就无需反复前往商店了，但也可能会惹恼对新产品没有兴趣的其他顾客。
&ensp;&ensp;&ensp;&ensp;似乎遇到了一个矛盾： 要么让顾客浪费时间检查产品是否到货， 要么让商店浪费资源去通知没有需求的顾客。

### 三、解决方案
&ensp;&ensp;&ensp;&ensp;拥有一些值得关注的状态的对象通常被称为目标， 由于它要将自身的状态改变通知给其他对象， 我们也将其称为发布者 （publisher）。 所有希望关注发布者状态变化的其他对象被称为订阅者 （subscribers）。
&ensp;&ensp;&ensp;&ensp;观察者模式建议你为发布者类添加订阅机制， 让每个对象都能订阅或取消订阅发布者事件流。 不要害怕！ 这并不像听上去那么复杂。 实际上， 该机制包括 1） 一个用于存储订阅者对象引用的列表成员变量； 2） 几个用于添加或删除该列表中订阅者的公有方法。
<div align=center><img src="observer_pattern_solution.png"></div>

&ensp;&ensp;&ensp;&ensp;现在， 无论何时发生了重要的发布者事件， 它都要遍历订阅者并调用其对象的特定通知方法。
&ensp;&ensp;&ensp;&ensp;实际应用中可能会有十几个不同的订阅者类跟踪着同一个发布者类的事件， 你不会希望发布者与所有这些类相耦合的。 此外如果他人会使用发布者类， 那么你甚至可能会对其中的一些类一无所知。
&ensp;&ensp;&ensp;&ensp;因此， 所有订阅者都必须实现同样的接口， 发布者仅通过该接口与订阅者交互。 接口中必须声明通知方法及其参数， 这样发布者在发出通知时还能传递一些上下文数据。
<div align=center><img src="observer_pattern_solution_1.png"></div>

&ensp;&ensp;&ensp;&ensp;如果你的应用中有多个不同类型的发布者， 且希望订阅者可兼容所有发布者， 那么你甚至可以进一步让所有发布者遵循同样的接口。 该接口仅需描述几个订阅方法即可。 这样订阅者就能在不与具体发布者类耦合的情况下通过接口观察发布者的状态。

### 四、观察者模式结构
<div align=center><img src="observer_pattern_structure.png"></div>

### 五、观察者模式适合changing
- 当一个对象状态的改变需要改变其他对象，或实际对象时事先未知的或动态变化时，可使用观察者模式
&ensp;&ensp;&ensp;&ensp;当你使用图形用户界面类时通常会遇到一个问题。比如，你创建了自定义按钮类并允许客户端在按钮中注入自定义代码，这样当用户按下按钮时就会触发这些代码。
&ensp;&ensp;&ensp;&ensp;观察者模式允许任何实现了订阅者接口的对象订阅发布者对象的事件通知。可以在按钮中添加订阅机制，允许客户端通过自定义订阅类注入自定义代码。
- 当应用中一些对象必须观察其他对象时，可使用观察者模式。但仅能在有限时间内或特定情况下使用。
&ensp;&ensp;&ensp;&ensp;订阅列表是动态的，因此订阅者可随时加入或离开该列表。

### 六、实现方式
- 仔细检查业务逻辑，试着将其拆分为两个部分：独立于其他代码的核心将作为发布者；其他代码则转化为一组订阅者
- 生命订阅者接口，该接口至少应声明一个update方法
- 声明发布者接口并定义一些接口来在列表中添加和删除订阅对象。记住发布者必须仅通过订阅者接口于它们进行交互
- 确定存放实际订阅列表的位置并实现订阅方法。通常所有类型的发布者代码看上去都一样， 因此将列表放置在直接扩展自发布者接口的抽象类中是显而易见的。 具体发布者会扩展该类从而继承所有的订阅行为。但是， 如果你需要在现有的类层次结构中应用该模式， 则可以考虑使用组合的方式： 将订阅逻辑放入一个独立的对象， 然后让所有实际订阅者使用该对象。
- 创建具体的发布者类。每次发布者发生了重要事件时都必须通知所有的订阅者。
- 在具体订阅者类中实现通知更新的方法。 绝大部分订阅者需要一些与事件相关的上下文数据。 这些数据可作为通知方法的参数来传递。但还有另一种选择。 订阅者接收到通知后直接从通知中获取所有数据。 在这种情况下， 发布者必须通过更新方法将自身传递出去。 另一种不太灵活的方式是通过构造函数将发布者与订阅者永久性地连接起来。
- 客户端必须生成所需的全部订阅者， 并在相应的发布者处完成注册工作。
### 七、优缺点
- 优点
  - 开闭原则。 你无需修改发布者代码就能引入新的订阅者类 （如果是发布者接口则可轻松引入发布者类）。
  - 你可以在运行时建立对象之间的联系
- 缺点
  - 订阅者的通知顺序是随机的